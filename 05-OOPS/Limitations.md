# Limitations of Inheritance and Polymorphism

1. Unnecessary complexity: Inheritance and polymorphism can add unnecessary complexity to software design if not used carefully. This can result in software that is difficult to maintain and debug.
2. Decreased performance: Inheritance and polymorphism can reduce software performance due to the additional overhead associated with their use.
3. Fragile base class problem: The "Fragile Base Class Problem" occurs when changes to a base class cause unexpected behavior in child classes.
4. Limited reusability: Inheritance and polymorphism can limit code reusability, as it is often difficult to reuse code based on inheritance or polymorphism.
5. Lack of flexibility: Inheritance and polymorphism can lack the flexibility necessary for some software designs. For example, if a software design requires the ability to extend the behavior of an object dynamically, then there may be better approaches than inheritance and polymorphism.

## Key Takeaways

1. Inheritance permits you to define a class that acquires from another class, giving it access to all the attributes and methods of the parent class. This permits code reuse and helps you make more productive code.
2. Polymorphism permits you to characterize methods within the parent class that can be overridden within the child class. This allows for a more secluded and flexible codebase because it permits distinctive objects to reply differently to the same method calls.
3. Both inheritance and polymorphism are effective programming techniques. When utilized legitimately, they can assist you in making more organized, effective, and robust code.
4. Python gives a number of features that make it simpler to utilize inheritance and polymorphism in your code. These incorporate extraordinary strategies like init() and str(), as well as the utilization of super() to get to the parent class.
5. Inheritance and polymorphism can be utilized together to form effective and extensible code. Be that as it may, it's imperative to use them appropriately, as they can lead to difficult-to-debug blunders in case not actualized accurately.
